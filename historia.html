<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Gu√≠a completa de algoritmia: C, C++, estructuras de datos, algoritmos cl√°sicos y complejidad Big-O con ejemplos en c√≥digo.">
  <meta name="author" content="Algoritmia ‚Äî Proyecto acad√©mico">
  <title>Gu√≠a de Algoritmia ‚Äî C, C++, Estructuras y Algoritmos</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

  <div id="progress-bar" role="progressbar" aria-label="Progreso de lectura" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>

  <!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <header>
    <button id="sidebar-toggle" aria-label="Abrir men√∫ de navegaci√≥n" aria-expanded="false" aria-controls="sidebar">‚ò∞</button>
    <a href="index.html" class="header-logo">Algo<span>ritmi</span>a</a>
    <nav class="header-nav" aria-label="Navegaci√≥n principal">
      <a href="index.html">Inicio</a>
      <a href="historia.html" class="active">Gu√≠a</a>
      <a href="contacto.html">Ejercicios</a>
    </nav>
    <div class="header-actions">
      <button id="theme-toggle" aria-label="Cambiar tema">‚óë Oscuro</button>
    </div>
  </header>

  <!-- ‚îÄ‚îÄ Layout ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div class="layout">

    <!-- Overlay para m√≥vil -->
    <div class="sidebar-overlay" id="sidebar-overlay" aria-hidden="true"></div>

    <!-- ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <aside class="sidebar" id="sidebar" aria-label="√çndice de contenido">
      <p class="sidebar-title">En esta p√°gina</p>
      <nav aria-label="Secciones de la gu√≠a">
        <a href="#c"><span class="dot"></span>C para algoritmia</a>
        <a href="#cpp"><span class="dot"></span>C++ para algoritmia</a>
        <a href="#estructuras"><span class="dot"></span>Estructuras de datos</a>
        <a href="#clasicos"><span class="dot"></span>Algoritmos cl√°sicos</a>
        <a href="#big-o"><span class="dot"></span>Complejidad Big-O</a>
        <a href="#fuentes"><span class="dot"></span>Fuentes recomendadas</a>
      </nav>
      <p class="sidebar-title" style="margin-top:var(--sp-5);">Otras p√°ginas</p>
      <nav aria-label="Navegaci√≥n del sitio">
        <a href="index.html"><span class="dot"></span>Inicio y fundamentos</a>
        <a href="contacto.html"><span class="dot"></span>Ejercicios y contacto</a>
      </nav>
    </aside>

    <!-- ‚îÄ‚îÄ Main ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <main id="main-content">
      <div class="content-wrapper">

        <p class="section-label">Gu√≠a completa</p>
        <h1>Manual de algoritmia en C y C++</h1>
        <p class="lead">
          Esta gu√≠a cubre los conceptos esenciales que necesitas para programar algoritmos eficientemente:
          desde la sintaxis de C hasta el STL de C++, pasando por las estructuras de datos m√°s utilizadas
          y los algoritmos cl√°sicos que debes conocer.
        </p>

        <hr class="divider">

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             SECCI√ìN C
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="c" aria-labelledby="c-title">
          <p class="section-label">Lenguaje base</p>
          <h2 id="c-title">C para algoritmia</h2>
          <p>
            C es el lenguaje de referencia para estudiar algoritmia por su cercan√≠a con el hardware y su
            control expl√≠cito de memoria. Entender C profundamente te ayuda a comprender qu√© pasa "debajo"
            cuando usas lenguajes de m√°s alto nivel.
          </p>

          <h3>Variables y tipos de datos esenciales</h3>
          <p>
            Los tipos m√°s usados en problemas de algoritmia son <code>int</code> (enteros),
            <code>long long</code> (enteros grandes, hasta ~9.2√ó10¬π‚Å∏), <code>double</code> (decimales)
            y <code>char</code> (caracteres). Declara las variables lo m√°s cerca posible de donde las usas.
          </p>

          <h3>Condicionales y ciclos</h3>
          <p>
            El <code>if/else</code> y el operador ternario <code>?:</code> controlan el flujo. Para
            iteraciones usa <code>for</code> cuando conoces el n√∫mero de repeticiones y <code>while</code>
            cuando dependes de una condici√≥n. El ciclo <code>do-while</code> garantiza al menos una ejecuci√≥n.
          </p>

          <h3>Funciones y arreglos</h3>
          <p>
            Divide tu soluci√≥n en funciones peque√±as y bien nombradas. Los arreglos en C son contiguos en
            memoria: <code>int arr[100]</code> reserva 100 enteros. Pasa arreglos a funciones con un puntero
            y el tama√±o por separado, ya que C no guarda la longitud autom√°ticamente.
          </p>

          <h3>Ejemplo 1: suma de un arreglo</h3>
          <pre><code><span class="kw">#include</span> &lt;stdio.h&gt;

<span class="cm">/* Retorna la suma de los primeros n elementos de arr */</span>
<span class="ty">int</span> <span class="fn">sumaArreglo</span>(<span class="ty">int</span> arr[], <span class="ty">int</span> n) {
    <span class="ty">int</span> total = <span class="nm">0</span>;
    <span class="kw">for</span> (<span class="ty">int</span> i = <span class="nm">0</span>; i &lt; n; i++) {
        total += arr[i];
    }
    <span class="kw">return</span> total;
}

<span class="ty">int</span> <span class="fn">main</span>(<span class="ty">void</span>) {
    <span class="ty">int</span> datos[] = {<span class="nm">3</span>, <span class="nm">7</span>, <span class="nm">2</span>, <span class="nm">9</span>, <span class="nm">4</span>};
    <span class="ty">int</span> n = <span class="kw">sizeof</span>(datos) / <span class="kw">sizeof</span>(datos[<span class="nm">0</span>]);
    <span class="fn">printf</span>(<span class="st">"Suma: %d\n"</span>, <span class="fn">sumaArreglo</span>(datos, n));
    <span class="kw">return</span> <span class="nm">0</span>;
}
</code></pre>
          <p class="code-caption">Suma de arreglo en C. El truco de <code>sizeof(arr)/sizeof(arr[0])</code> calcula la cantidad de elementos solo dentro del √°mbito donde el arreglo fue declarado.</p>

          <h3>Ejemplo 2: b√∫squeda lineal con funci√≥n</h3>
          <pre><code><span class="kw">#include</span> &lt;stdio.h&gt;

<span class="cm">/* Retorna el √≠ndice de 'objetivo' en arr, o -1 si no existe */</span>
<span class="ty">int</span> <span class="fn">busquedaLineal</span>(<span class="ty">int</span> arr[], <span class="ty">int</span> n, <span class="ty">int</span> objetivo) {
    <span class="kw">for</span> (<span class="ty">int</span> i = <span class="nm">0</span>; i &lt; n; i++) {
        <span class="kw">if</span> (arr[i] == objetivo)
            <span class="kw">return</span> i;
    }
    <span class="kw">return</span> -<span class="nm">1</span>;
}

<span class="ty">int</span> <span class="fn">main</span>(<span class="ty">void</span>) {
    <span class="ty">int</span> datos[] = {<span class="nm">10</span>, <span class="nm">25</span>, <span class="nm">8</span>, <span class="nm">42</span>, <span class="nm">3</span>};
    <span class="ty">int</span> n = <span class="kw">sizeof</span>(datos) / <span class="kw">sizeof</span>(datos[<span class="nm">0</span>]);
    <span class="ty">int</span> pos = <span class="fn">busquedaLineal</span>(datos, n, <span class="nm">42</span>);
    <span class="kw">if</span> (pos != -<span class="nm">1</span>)
        <span class="fn">printf</span>(<span class="st">"Encontrado en √≠ndice %d\n"</span>, pos);
    <span class="kw">else</span>
        <span class="fn">printf</span>(<span class="st">"No encontrado\n"</span>);
    <span class="kw">return</span> <span class="nm">0</span>;
}
</code></pre>
          <p class="code-caption">B√∫squeda lineal: O(n) en el peor caso. Funciona en arreglos desordenados.</p>

          <div class="callout callout-nota">
            <p class="callout-label">üìù Nota</p>
            <p>Cuando uses memoria din√°mica (<code>malloc</code>/<code>calloc</code>), siempre lib√©rala con
            <code>free()</code>. Los fugas de memoria no causan errores inmediatos, pero degradan el rendimiento
            en programas largos y pueden ser dif√≠ciles de depurar.</p>
          </div>
        </section>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             SECCI√ìN C++
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="cpp" aria-labelledby="cpp-title">
          <p class="section-label">El siguiente paso</p>
          <h2 id="cpp-title">C++ para algoritmia</h2>
          <p>
            C++ extiende C con orientaci√≥n a objetos, pero para algoritmia lo m√°s valioso es su
            <strong>Standard Template Library (STL)</strong>: contenedores gen√©ricos, iteradores y algoritmos
            ya implementados y probados. Usarlos correctamente marca la diferencia en competencias y proyectos.
          </p>

          <h3>Entrada/salida con iostream</h3>
          <p>
            Usa <code>cin</code> y <code>cout</code> en lugar de <code>scanf/printf</code>. Para competencias,
            agrega <code>ios::sync_with_stdio(false); cin.tie(NULL);</code> al inicio del <code>main</code>
            para acelerar significativamente la lectura de datos grandes.
          </p>

          <h3>Vector: el arreglo din√°mico de C++</h3>
          <p>
            <code>std::vector&lt;int&gt;</code> es un arreglo que crece autom√°ticamente. Ofrece acceso
            aleatorio en O(1), inserci√≥n al final en O(1) amortizado, y la conveniencia de conocer su
            tama√±o con <code>.size()</code>. Es la estructura por defecto cuando no sabes el tama√±o exacto
            de antemano.
          </p>

          <h3>Ejemplo 1: uso de vector y sort</h3>
          <pre><code><span class="kw">#include</span> &lt;iostream&gt;
<span class="kw">#include</span> &lt;vector&gt;
<span class="kw">#include</span> &lt;algorithm&gt;
<span class="kw">using namespace</span> std;

<span class="ty">int</span> <span class="fn">main</span>() {
    <span class="cm">// Leer n n√∫meros y almacenarlos en un vector</span>
    <span class="ty">int</span> n;
    cin >> n;
    vector&lt;<span class="ty">int</span>&gt; nums(n);
    <span class="kw">for</span> (<span class="ty">int</span> i = <span class="nm">0</span>; i &lt; n; i++) cin >> nums[i];

    <span class="cm">// Ordenar en O(n log n) con std::sort</span>
    <span class="fn">sort</span>(nums.<span class="fn">begin</span>(), nums.<span class="fn">end</span>());

    cout &lt;&lt; <span class="st">"Ordenados: "</span>;
    <span class="kw">for</span> (<span class="ty">int</span> x : nums) cout &lt;&lt; x &lt;&lt; <span class="st">" "</span>;
    cout &lt;&lt; <span class="st">"\n"</span>;
    <span class="kw">return</span> <span class="nm">0</span>;
}
</code></pre>
          <p class="code-caption"><code>std::sort</code> implementa Introsort (h√≠brido de quicksort, heapsort y insertion sort) con complejidad garantizada O(n log n).</p>

          <h3>Ejemplo 2: map y set para frecuencias</h3>
          <pre><code><span class="kw">#include</span> &lt;iostream&gt;
<span class="kw">#include</span> &lt;map&gt;
<span class="kw">using namespace</span> std;

<span class="ty">int</span> <span class="fn">main</span>() {
    <span class="cm">// Contar frecuencia de palabras</span>
    map&lt;string, <span class="ty">int</span>&gt; freq;
    string palabra;
    <span class="kw">while</span> (cin >> palabra) {
        freq[palabra]++;
    }
    <span class="kw">for</span> (<span class="kw">auto</span>&amp; [key, val] : freq) {
        cout &lt;&lt; key &lt;&lt; <span class="st">": "</span> &lt;&lt; val &lt;&lt; <span class="st">"\n"</span>;
    }
    <span class="kw">return</span> <span class="nm">0</span>;
}
</code></pre>
          <p class="code-caption"><code>std::map</code> es un √°rbol balanceado (BST) con operaciones O(log n). Si solo necesitas b√∫squeda r√°pida sin orden, usa <code>unordered_map</code> con O(1) promedio.</p>

          <div class="callout callout-tip">
            <p class="callout-label">üí° Tip STL esencial</p>
            <p>Para competencias y proyectos, domina al menos: <code>vector</code>, <code>map</code>,
            <code>unordered_map</code>, <code>set</code>, <code>queue</code>, <code>stack</code>,
            <code>priority_queue</code> y los algoritmos <code>sort</code>, <code>binary_search</code>,
            <code>lower_bound</code> y <code>upper_bound</code>. Con estos ya puedes resolver la mayor√≠a de
            los problemas de nivel intermedio.</p>
          </div>

          <h3>Referencias y paso por referencia</h3>
          <p>
            A diferencia de C, en C++ puedes pasar por referencia con <code>&amp;</code>. Esto evita copiar
            estructuras grandes y permite modificar el valor original desde una funci√≥n. Usa
            <code>const&amp;</code> cuando no necesitas modificar el par√°metro para expresar esa intenci√≥n
            expl√≠citamente y permitir al compilador optimizar.
          </p>
        </section>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             ESTRUCTURAS DE DATOS
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="estructuras" aria-labelledby="est-title">
          <p class="section-label">Organizar la informaci√≥n</p>
          <h2 id="est-title">Estructuras de datos</h2>
          <p>
            Una estructura de datos es una forma de organizar informaci√≥n en memoria para que ciertas
            operaciones ‚Äîb√∫squeda, inserci√≥n, eliminaci√≥n‚Äî sean eficientes. Elegir la estructura correcta
            frecuentemente es la mitad de la soluci√≥n.
          </p>

          <div style="display:flex; justify-content:center; margin: var(--sp-5) 0;">
            <img src="assets/stack-queue.jpg"
                 alt="Diagrama comparativo de Pila (Stack, LIFO) y Cola (Queue, FIFO) mostrando c√≥mo se insertan y extraen elementos"
                 width="360" height="200">
          </div>

          <h3>Arreglos (Arrays)</h3>
          <p>
            Colecci√≥n de elementos del mismo tipo almacenados de forma contigua en memoria. Acceso aleatorio
            en O(1), pero inserci√≥n y eliminaci√≥n en posiciones intermedias requieren O(n) por el desplazamiento
            de elementos. √ösalos cuando el tama√±o es conocido y el acceso por √≠ndice es frecuente.
          </p>

          <h3>Listas enlazadas</h3>
          <p>
            Cada nodo contiene el dato y un puntero al siguiente. Inserci√≥n y eliminaci√≥n en O(1) si tienes
            el puntero al nodo previo, pero el acceso por posici√≥n es O(n). En la pr√°ctica, <code>std::list</code>
            de C++ se usa poco porque los vectores suelen ser m√°s eficientes en cach√©.
          </p>

          <h3>Pilas (Stack) y Colas (Queue)</h3>
          <p>
            La <strong>pila</strong> (LIFO) permite insertar y extraer solo por el tope. Es fundamental para
            recursi√≥n, evaluaci√≥n de expresiones y DFS iterativo. La <strong>cola</strong> (FIFO) extrae por
            el frente e inserta por el final; es clave para BFS y simulaciones de procesos.
          </p>

          <h3>√Årboles</h3>
          <p>
            Un √°rbol binario de b√∫squeda (BST) permite b√∫squeda, inserci√≥n y eliminaci√≥n en O(log n)
            <em>si est√° balanceado</em>. Los √°rboles AVL y los Red-Black Trees garantizan el balance
            autom√°ticamente. En C++, <code>std::map</code> y <code>std::set</code> est√°n implementados como
            √°rboles Red-Black.
          </p>

          <h3>Tablas hash (Hash Tables)</h3>
          <p>
            Ofrecen b√∫squeda, inserci√≥n y eliminaci√≥n en O(1) promedio. La eficiencia depende de la funci√≥n
            hash y el manejo de colisiones. En C++, <code>unordered_map</code> y <code>unordered_set</code>
            son las implementaciones est√°ndar.
          </p>

          <h4>¬øCu√°ndo usar cada estructura?</h4>
          <div class="table-wrap">
            <table aria-label="Comparativa de estructuras de datos: cu√°ndo usar cada una">
              <thead>
                <tr>
                  <th>Estructura</th>
                  <th>Acceso</th>
                  <th>Inserci√≥n</th>
                  <th>B√∫squeda</th>
                  <th>√ösala cuando‚Ä¶</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Arreglo / Vector</td>
                  <td><span class="badge-o">O(1)</span></td>
                  <td><span class="badge-o medium">O(n)*</span></td>
                  <td><span class="badge-o medium">O(n)</span></td>
                  <td>Acceso por √≠ndice frecuente, tama√±o relativamente fijo.</td>
                </tr>
                <tr>
                  <td>Lista enlazada</td>
                  <td><span class="badge-o medium">O(n)</span></td>
                  <td><span class="badge-o">O(1)</span></td>
                  <td><span class="badge-o medium">O(n)</span></td>
                  <td>Muchas inserciones/eliminaciones en posiciones arbitrarias.</td>
                </tr>
                <tr>
                  <td>Stack / Queue</td>
                  <td>Solo tope/frente</td>
                  <td><span class="badge-o">O(1)</span></td>
                  <td>‚Äî</td>
                  <td>DFS (stack), BFS (queue), historial de acciones.</td>
                </tr>
                <tr>
                  <td>BST / Map / Set</td>
                  <td><span class="badge-o">O(log n)</span></td>
                  <td><span class="badge-o">O(log n)</span></td>
                  <td><span class="badge-o">O(log n)</span></td>
                  <td>Datos ordenados, rangos, m√≠nimo/m√°ximo din√°mico.</td>
                </tr>
                <tr>
                  <td>Hash / Unordered</td>
                  <td><span class="badge-o">O(1) prom.</span></td>
                  <td><span class="badge-o">O(1) prom.</span></td>
                  <td><span class="badge-o">O(1) prom.</span></td>
                  <td>Frecuencias, lookups r√°pidos sin necesitar orden.</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p class="code-caption">*Inserci√≥n al final de vector es O(1) amortizado. Al inicio o en posici√≥n arbitraria es O(n).</p>
        </section>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             ALGORITMOS CL√ÅSICOS
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="clasicos" aria-labelledby="clas-title">
          <p class="section-label">Herramientas fundamentales</p>
          <h2 id="clas-title">Algoritmos cl√°sicos</h2>
          <p>
            Hay un conjunto de algoritmos que todo programador debe conocer porque aparecen una y otra vez
            en problemas reales. No hace falta memorizarlos: el objetivo es entender <em>cu√°ndo</em> aplica
            cada uno y ser capaz de implementarlo sin referencia.
          </p>

          <h3>B√∫squeda lineal y b√∫squeda binaria</h3>
          <p>
            La <strong>b√∫squeda lineal</strong> recorre todos los elementos hasta encontrar el objetivo: O(n),
            funciona en arreglos no ordenados. La <strong>b√∫squeda binaria</strong> aprovecha el orden para
            dividir el espacio de b√∫squeda a la mitad en cada paso: O(log n). Para n=1,000,000, la b√∫squeda
            binaria necesita solo ~20 comparaciones.
          </p>
          <pre><code><span class="cm">// B√∫squeda binaria iterativa en C++ (arreglo ordenado)</span>
<span class="ty">int</span> <span class="fn">binaria</span>(vector&lt;<span class="ty">int</span>&gt;&amp; arr, <span class="ty">int</span> objetivo) {
    <span class="ty">int</span> izq = <span class="nm">0</span>, der = arr.<span class="fn">size</span>() - <span class="nm">1</span>;
    <span class="kw">while</span> (izq &lt;= der) {
        <span class="ty">int</span> mid = izq + (der - izq) / <span class="nm">2</span>; <span class="cm">// evita overflow</span>
        <span class="kw">if</span> (arr[mid] == objetivo) <span class="kw">return</span> mid;
        <span class="kw">if</span> (arr[mid] &lt; objetivo)  izq = mid + <span class="nm">1</span>;
        <span class="kw">else</span>                       der = mid - <span class="nm">1</span>;
    }
    <span class="kw">return</span> -<span class="nm">1</span>; <span class="cm">// no encontrado</span>
}
</code></pre>
          <p class="code-caption">Usar <code>mid = izq + (der-izq)/2</code> en lugar de <code>(izq+der)/2</code> previene desbordamiento entero cuando los √≠ndices son grandes.</p>

          <h3>Algoritmos de ordenamiento</h3>
          <p>
            Los algoritmos simples como <strong>Bubble Sort</strong> y <strong>Selection Sort</strong> tienen
            O(n¬≤) y sirven solo para conjuntos peque√±os o para aprender el concepto. En la pr√°ctica, usa
            siempre <code>std::sort</code> de C++ que implementa Introsort con O(n log n) garantizado.
          </p>
          <p>
            <strong>Merge Sort</strong> divide el arreglo en dos mitades, ordena cada mitad recursivamente y
            las fusiona en O(n log n). Es estable (mantiene el orden relativo de elementos iguales) y predecible.
            <strong>Quick Sort</strong> elige un pivote, particiona alrededor de √©l y ordena las particiones
            recursivamente: O(n log n) promedio, O(n¬≤) en el peor caso (que se evita con pivote aleatorio).
          </p>

          <div class="callout callout-tip">
            <p class="callout-label">üí° Regla pr√°ctica de ordenamiento</p>
            <p>Usa <code>std::sort</code> siempre que puedas. Solo implementa tu propio algoritmo de
            ordenamiento en competencias que lo pidan expl√≠citamente, para aprender, o cuando necesites
            una variante espec√≠fica como conteo de inversiones con Merge Sort.</p>
          </div>

          <h3>BFS ‚Äî B√∫squeda en Anchura</h3>
          <p>
            BFS (Breadth-First Search) explora un grafo nivel por nivel usando una <strong>cola</strong>.
            Visita primero todos los vecinos del nodo inicial, luego los vecinos de esos vecinos, y as√≠
            sucesivamente. Es ideal para encontrar el <em>camino m√°s corto</em> en grafos no ponderados
            (donde todas las aristas tienen el mismo peso).
          </p>
          <p>
            Casos de uso t√≠picos: distancia m√≠nima en laberintos, n√∫mero m√≠nimo de pasos, componentes
            conectados, y verificar si un grafo es bipartito.
          </p>

          <h3>DFS ‚Äî B√∫squeda en Profundidad</h3>
          <p>
            DFS (Depth-First Search) explora tan lejos como sea posible por cada rama antes de retroceder.
            Se implementa con recursi√≥n (usando la pila de llamadas) o con una <strong>pila</strong> expl√≠cita.
            Es fundamental para detecci√≥n de ciclos, ordenamiento topol√≥gico, componentes fuertemente
            conectados y la mayor√≠a de los algoritmos de √°rboles.
          </p>

          <div class="callout callout-nota">
            <p class="callout-label">üìù BFS vs DFS</p>
            <p><strong>BFS</strong>: distancia m√≠nima, nivel por nivel. Usa m√°s memoria (guarda todos los nodos del nivel actual).<br>
            <strong>DFS</strong>: exploraci√≥n profunda, ciclos, topolog√≠a. Usa menos memoria en grafos anchos pero puede apilar mucho en grafos profundos.</p>
          </div>

          <div class="callout callout-warn">
            <p class="callout-label">‚ö† Advertencia</p>
            <p>En DFS recursivo, si el grafo tiene miles de nodos encadenados (como una lista enlazada grande),
            puedes agotar la pila de llamadas del sistema y causar un <em>stack overflow</em>. En ese caso,
            implementa DFS iterativo con una pila expl√≠cita (<code>std::stack</code>).</p>
          </div>
        </section>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             BIG-O PROFUNDO
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="big-o" aria-labelledby="bigo-title">
          <p class="section-label">An√°lisis de eficiencia</p>
          <h2 id="bigo-title">Complejidad Big-O: gu√≠a pr√°ctica</h2>
          <p>
            La notaci√≥n Big-O describe el peor caso de crecimiento de un algoritmo. Al analizar c√≥digo, busca
            los bucles: un <code>for</code> simple sobre n elementos contribuye O(n). Dos <code>for</code>
            anidados sobre los mismos n elementos dan O(n¬≤). Una funci√≥n recursiva que divide el problema a
            la mitad en cada llamada suele ser O(log n) o O(n log n).
          </p>
          <p>
            Las constantes se ignoran en Big-O: O(3n) = O(n). Los t√©rminos de menor orden tambi√©n se eliminan:
            O(n¬≤ + n) = O(n¬≤). Esto refleja que para entradas muy grandes, el t√©rmino dominante determina el
            comportamiento.
          </p>

          <h3>C√≥mo calcular complejidad en la pr√°ctica</h3>
          <ul>
            <li>Identifica el tama√±o de la entrada: suele ser <em>n</em>, pero puede ser la longitud de una cadena, el n√∫mero de v√©rtices de un grafo, etc.</li>
            <li>Cuenta las operaciones dominantes: comparaciones, accesos a arreglo, llamadas a funci√≥n.</li>
            <li>Si hay un <code>for</code> de 1 a n que dentro llama a <code>sort</code>, la complejidad total es O(n ¬∑ n log n) = O(n¬≤ log n).</li>
            <li>La recursi√≥n tiene un √°rbol de llamadas: el n√∫mero de hojas y la profundidad determinan la complejidad.</li>
          </ul>

          <h3>L√≠mites pr√°cticos por tiempo de ejecuci√≥n</h3>
          <div class="table-wrap">
            <table aria-label="L√≠mites de operaciones seg√∫n complejidad y tiempo permitido">
              <thead>
                <tr>
                  <th>Complejidad</th>
                  <th>n m√°ximo aprox. en 1 segundo</th>
                  <th>Contexto</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><span class="badge-o">O(1) ‚Äî O(log n)</span></td>
                  <td>Cualquier n razonable</td>
                  <td>B√∫squeda binaria, hash lookup</td>
                </tr>
                <tr>
                  <td><span class="badge-o">O(n)</span></td>
                  <td>~10‚Å∏</td>
                  <td>Recorrido de arreglo, suma</td>
                </tr>
                <tr>
                  <td><span class="badge-o">O(n log n)</span></td>
                  <td>~10‚Å∑</td>
                  <td>Ordenamiento, Merge Sort</td>
                </tr>
                <tr>
                  <td><span class="badge-o medium">O(n¬≤)</span></td>
                  <td>~10‚Å¥ ‚Äî 10‚Åµ</td>
                  <td>Dos bucles anidados</td>
                </tr>
                <tr>
                  <td><span class="badge-o bad">O(2‚Åø)</span></td>
                  <td>~20 ‚Äî 25</td>
                  <td>Subconjuntos, fuerza bruta exponencial</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="callout callout-tip">
            <p class="callout-label">üí° Consejo final</p>
            <p>Antes de optimizar prematuramente, comprueba que tu soluci√≥n es correcta. Una soluci√≥n O(n¬≤)
            correcta es mejor que una O(n log n) con bugs. Optimiza solo cuando el an√°lisis de complejidad
            indique que superar√°s el l√≠mite de tiempo.</p>
          </div>
        </section>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             FUENTES
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="fuentes" aria-labelledby="fuentes-title">
          <p class="section-label">Para ir m√°s lejos</p>
          <h2 id="fuentes-title">Fuentes y lecturas recomendadas</h2>
          <p>
            Las siguientes son fuentes de primera l√≠nea, ampliamente reconocidas en la comunidad acad√©mica y
            profesional. No inventamos ni fabricamos referencias.
          </p>
          <ul>
            <li>
              <strong>Cormen, Leiserson, Rivest & Stein ‚Äî Introduction to Algorithms (CLRS), 4¬™ ed.</strong><br>
              El libro de referencia por excelencia. Cubre pr√°cticamente todos los algoritmos cl√°sicos con
              demostraciones formales y an√°lisis de complejidad riguroso.
            </li>
            <li>
              <strong>Knuth ‚Äî The Art of Computer Programming (Vols. 1‚Äì4A)</strong><br>
              La obra m√°s exhaustiva sobre el tema. Matem√°ticamente profunda. Recomendada para quienes buscan
              el fundamento te√≥rico completo.
            </li>
            <li>
              <strong>Sedgewick & Wayne ‚Äî Algorithms, 4¬™ ed.</strong><br>
              Excelente equilibrio entre teor√≠a y pr√°ctica. Incluye visualizaciones y est√° escrito de forma
              m√°s accesible que CLRS.
            </li>
            <li>
              <strong>MIT OpenCourseWare ‚Äî 6.006 Introduction to Algorithms y 6.046 Design and Analysis of Algorithms</strong><br>
              Cursos completos, con notas, videos y tareas disponibles gratuitamente en ocw.mit.edu.
            </li>
            <li>
              <strong>Stanford University ‚Äî CS161 (Algorithms) y materiales del Algorithms Specialization en Coursera</strong><br>
              Tim Roughgarden ofrece explicaciones muy claras sobre divide y vencer√°s, grafos y programaci√≥n din√°mica.
            </li>
            <li>
              <strong>cp-algorithms.com</strong><br>
              Referencia pr√°ctica orientada a programaci√≥n competitiva. Cubre implementaciones detalladas
              de algoritmos avanzados con pseudoc√≥digo y c√≥digo C++.
            </li>
          </ul>

          <div class="callout callout-nota">
            <p class="callout-label">üìù C√≥mo usar estas fuentes</p>
            <p>No necesitas leer CLRS de principio a fin desde el primer d√≠a. √ösalo como diccionario: cuando
            encuentres un algoritmo nuevo, b√∫scalo ah√≠ para ver su demostraci√≥n formal. Los cursos de MIT y
            Stanford son ideales para aprender en secuencia y ver los conceptos en movimiento.</p>
          </div>
        </section>

      </div><!-- /.content-wrapper -->
    </main>
  </div><!-- /.layout -->

  <!-- ‚îÄ‚îÄ Footer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <footer>
    <div class="footer-inner">
      <div class="footer-col">
        <h4>P√°ginas</h4>
        <ul>
          <li><a href="index.html">Inicio</a></li>
          <li><a href="historia.html">Gu√≠a completa</a></li>
          <li><a href="contacto.html">Ejercicios y contacto</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <h4>Secciones de esta gu√≠a</h4>
        <ul>
          <li><a href="#c">C para algoritmia</a></li>
          <li><a href="#cpp">C++ para algoritmia</a></li>
          <li><a href="#estructuras">Estructuras de datos</a></li>
          <li><a href="#clasicos">Algoritmos cl√°sicos</a></li>
          <li><a href="#big-o">Complejidad Big-O</a></li>
          <li><a href="#fuentes">Fuentes</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <h4>Fuentes de referencia</h4>
        <ul>
          <li>Cormen et al. ‚Äî Introduction to Algorithms (CLRS)</li>
          <li>Knuth ‚Äî The Art of Computer Programming</li>
          <li>Sedgewick & Wayne ‚Äî Algorithms</li>
          <li>MIT OpenCourseWare ¬∑ Stanford CS</li>
          <li>cp-algorithms.com</li>
        </ul>
      </div>
    </div>
    <div class="footer-copy">
      <span>Proyecto acad√©mico de algoritmia ‚Äî HTML/CSS/JS puro</span>
      <span>Derechos Reservados</span>
    </div>
  </footer>

  <button id="back-to-top" aria-label="Volver al inicio">‚Üë</button>
  <script src="app.js"></script>
</body>
</html>