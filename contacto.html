<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Ejercicios progresivos de algoritmia en C y C++, desde nivel b√°sico hasta retos avanzados. Incluye formulario de contacto.">
  <meta name="author" content="Algoritmia ‚Äî Proyecto acad√©mico">
  <title>Ejercicios y Contacto ‚Äî Algoritmia</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="no-sidebar">

  <div id="progress-bar" role="progressbar" aria-hidden="true"></div>

  <!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <header>
    <a href="index.html" class="header-logo">Algo<span>ritmi</span>a</a>
    <nav class="header-nav" aria-label="Navegaci√≥n principal">
      <a href="index.html">Inicio</a>
      <a href="historia.html">Gu√≠a</a>
      <a href="contacto.html" class="active">Ejercicios</a>
    </nav>
    <div class="header-actions">
      <button id="theme-toggle" aria-label="Cambiar tema">‚óë Oscuro</button>
    </div>
  </header>

  <div class="layout">
    <main id="main-content">
      <div class="content-wrapper">

        <p class="section-label">Practica y consolida</p>
        <h1>Ejercicios y retos de algoritmia</h1>
        <p class="lead">
          La mejor forma de aprender algoritmia es resolvi√©ndola. Esta secci√≥n ofrece ejercicios progresivos:
          empieza por los b√°sicos aunque te parezcan sencillos; la claridad conceptual que obtendr√°s es
          el fundamento para resolver los m√°s dif√≠ciles.
        </p>

        <!-- Imagen de ruta -->
        <div style="display:flex; justify-content:center; margin: var(--sp-5) 0;">
          <img src="assets/ejercicios-ruta.png"
               alt="Diagrama de la ruta de pr√°ctica: desde ejercicios f√°ciles, pasando por nivel b√°sico e intermedio, hasta los retos avanzados"
               width="400" height="80">
        </div>

        <hr class="divider">

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             EJERCICIOS B√ÅSICOS (1-5)
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="ejercicios" aria-labelledby="ej-title">
          <p class="section-label">Nivel f√°cil</p>
          <h2 id="ej-title">Ejercicios b√°sicos (1 ‚Äì 5)</h2>
          <p>
            Estos ejercicios caben en menos de 20 l√≠neas de c√≥digo. Su objetivo no es ser dif√≠ciles, sino
            construir el h√°bito de pensar antes de programar y verificar los casos borde.
          </p>

          <!-- Ejercicio 1 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 01</p>
            <div><span class="tag tag-green">Arrays</span><span class="tag tag-green">Bucles</span></div>
            <h3>Suma y promedio de un arreglo</h3>
            <p><strong>Objetivo:</strong> Dado un arreglo de <em>n</em> enteros le√≠dos desde stdin, imprime su suma y su promedio (como decimal).</p>
            <p><strong>Concepto practicado:</strong> Lectura de arreglos, bucle <code>for</code>, tipos <code>int</code> vs <code>double</code>.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Recuerda hacer el cast antes de dividir: <code>(double)suma / n</code>. Si divides dos enteros obtendr√°s un entero.</div>
          </article>

          <!-- Ejercicio 2 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 02</p>
            <div><span class="tag tag-green">Strings</span><span class="tag tag-green">Condicionales</span></div>
            <h3>¬øEs pal√≠ndromo?</h3>
            <p><strong>Objetivo:</strong> Lee una cadena de texto y determina si es pal√≠ndromo (se lee igual al derecho y al rev√©s). Ignora may√∫sculas/min√∫sculas.</p>
            <p><strong>Concepto practicado:</strong> Recorrido de cadenas, √≠ndices desde ambos extremos, <code>tolower()</code>.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Usa dos √≠ndices: <code>i = 0</code> e <code>j = s.size()-1</code>. Avanza ambos hacia el centro mientras <code>s[i] == s[j]</code>. Si se cruzan sin diferencias, es pal√≠ndromo.</div>
          </article>

          <!-- Ejercicio 3 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 03</p>
            <div><span class="tag tag-green">Matem√°ticas</span><span class="tag tag-green">Bucles</span></div>
            <h3>N√∫meros primos hasta N</h3>
            <p><strong>Objetivo:</strong> Imprime todos los n√∫meros primos menores o iguales a N usando la Criba de Erat√≥stenes.</p>
            <p><strong>Concepto practicado:</strong> Algoritmos con arreglos booleanos, cribas, eficiencia b√°sica.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Declara <code>bool primo[N+1]</code> inicializado en <code>true</code>. Por cada n√∫mero <em>p</em> primo (no marcado como falso), marca sus m√∫ltiplos desde <em>p¬≤</em> hasta N como <code>false</code>.</div>
          </article>

          <!-- Ejercicio 4 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 04</p>
            <div><span class="tag tag-green">Recursi√≥n</span><span class="tag tag-green">Funciones</span></div>
            <h3>Fibonacci iterativo vs recursivo</h3>
            <p><strong>Objetivo:</strong> Implementa una funci√≥n Fibonacci recursiva y otra iterativa. Para n = 40, mide (informalmente) cu√°l es m√°s r√°pida y razona el porqu√©.</p>
            <p><strong>Concepto practicado:</strong> Recursi√≥n, √°rbol de llamadas, introducci√≥n a memoizaci√≥n.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">La versi√≥n recursiva naive recalcula los mismos valores muchas veces: fib(5) llama a fib(4) y fib(3), y fib(4) vuelve a llamar a fib(3). Eso es exponencial. La iterativa es O(n).</div>
          </article>

          <!-- Ejercicio 5 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 05</p>
            <div><span class="tag tag-green">Arrays</span><span class="tag tag-green">B√∫squeda</span></div>
            <h3>Elemento mayoritario</h3>
            <p><strong>Objetivo:</strong> Dado un arreglo de n enteros, determina si existe un elemento que aparece m√°s de n/2 veces (elemento mayoritario). Si existe, impr√≠melo; si no, imprime "Ninguno".</p>
            <p><strong>Concepto practicado:</strong> Frecuencias, uso de <code>map</code> o arreglo auxiliar.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Soluci√≥n simple: usa un <code>unordered_map&lt;int,int&gt;</code> para contar frecuencias en O(n). Luego recorre el mapa buscando el elemento con frecuencia mayor a n/2.</div>
          </article>
        </section>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             EJERCICIOS INTERMEDIOS (6-10)
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="ejercicios-medio" aria-labelledby="ej-medio-title">
          <p class="section-label">Nivel intermedio</p>
          <h2 id="ej-medio-title">Ejercicios intermedios (6 ‚Äì 10)</h2>
          <p>
            Estos ejercicios requieren combinar m√°s de una idea o estructura. T√≥mate el tiempo necesario:
            si te atascas, regresa a la gu√≠a o consulta las pistas.
          </p>

          <!-- Ejercicio 6 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 06</p>
            <div><span class="tag tag-orange">B√∫squeda binaria</span><span class="tag tag-orange">Arrays</span></div>
            <h3>B√∫squeda binaria en arreglo ordenado</h3>
            <p><strong>Objetivo:</strong> Implementa b√∫squeda binaria sin usar <code>std::binary_search</code>. El programa debe leer un arreglo ordenado de n enteros y responder q consultas: para cada consulta indica si el n√∫mero existe y en qu√© √≠ndice.</p>
            <p><strong>Concepto practicado:</strong> B√∫squeda binaria, √≠ndices <code>izq</code> / <code>der</code> / <code>mid</code>.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Calcula el punto medio como <code>mid = izq + (der - izq) / 2</code> para evitar overflow. Si <code>arr[mid] == objetivo</code>, retorna <code>mid</code>. Si <code>arr[mid] < objetivo</code>, mueve <code>izq = mid + 1</code>. Si no, mueve <code>der = mid - 1</code>.</div>
          </article>

          <!-- Ejercicio 7 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 07</p>
            <div><span class="tag tag-orange">Ordenamiento</span><span class="tag tag-orange">Divide y vencer√°s</span></div>
            <h3>Implementar Merge Sort</h3>
            <p><strong>Objetivo:</strong> Implementa Merge Sort desde cero en C++ y ordena un arreglo de n enteros. Verifica que el resultado sea correcto compar√°ndolo con <code>std::sort</code>.</p>
            <p><strong>Concepto practicado:</strong> Recursi√≥n, divide y vencer√°s, complejidad O(n log n).</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Divide el arreglo en dos mitades con √≠ndice <code>mid = (izq + der) / 2</code>. Llama recursivamente a mergeSort para ambas mitades. Luego fusiona: usa dos √≠ndices para recorrer ambas mitades y copia el menor a un arreglo temporal.</div>
          </article>

          <!-- Ejercicio 8 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 08</p>
            <div><span class="tag tag-orange">Stack</span><span class="tag tag-orange">Cadenas</span></div>
            <h3>Par√©ntesis balanceados</h3>
            <p><strong>Objetivo:</strong> Dado un string con <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, determina si los par√©ntesis est√°n correctamente balanceados y anidados.</p>
            <p><strong>Concepto practicado:</strong> Pilas (<code>std::stack</code>), recorrido de cadenas.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Usa una <code>stack&lt;char&gt;</code>. Al encontrar un par√©ntesis de apertura, ap√≠lalo. Al encontrar uno de cierre, verifica que el tope de la pila sea el correspondiente de apertura; si no, no est√° balanceado. Al final, la pila debe estar vac√≠a.</div>
          </article>

          <!-- Ejercicio 9 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 09</p>
            <div><span class="tag tag-orange">Grafos</span><span class="tag tag-orange">BFS</span></div>
            <h3>Laberinto: camino m√°s corto</h3>
            <p><strong>Objetivo:</strong> Dado un laberinto como una grilla de 0s (libre) y 1s (muro), encuentra la longitud del camino m√°s corto desde la celda inicial (0,0) hasta la celda destino (n-1, m-1). Si no existe camino, imprime -1.</p>
            <p><strong>Concepto practicado:</strong> BFS en grillas, <code>queue</code>, arreglo de visitados.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Usa BFS con una <code>queue&lt;pair&lt;int,int&gt;&gt;</code>. Empieza por (0,0) con distancia 0. Por cada celda, explora las 4 vecinas (arriba, abajo, izquierda, derecha) que sean 0 y no visitadas. Cuando llegas a (n-1, m-1), la distancia actual es la respuesta.</div>
          </article>

          <!-- Ejercicio 10 -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Ejercicio 10</p>
            <div><span class="tag tag-orange">Hash</span><span class="tag tag-orange">Frecuencias</span></div>
            <h3>Dos sumas (Two Sum)</h3>
            <p><strong>Objetivo:</strong> Dado un arreglo de n enteros y un valor objetivo T, encuentra dos √≠ndices i, j (i ‚â† j) tales que <code>arr[i] + arr[j] == T</code>. Si no existen, indica que no hay soluci√≥n. Implementa la soluci√≥n en O(n).</p>
            <p><strong>Concepto practicado:</strong> <code>unordered_map</code>, complemento: <code>T - arr[i]</code>.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Recorre el arreglo. Por cada elemento <code>arr[i]</code>, calcula su complemento <code>c = T - arr[i]</code>. Busca <code>c</code> en un <code>unordered_map</code> que mapea valor ‚Üí √≠ndice. Si est√°, encontraste la pareja. Si no, inserta <code>arr[i]</code> ‚Üí <code>i</code> en el mapa y contin√∫a.</div>
          </article>
        </section>

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             RETOS FINALES
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="retos" aria-labelledby="retos-title">
          <p class="section-label">Desaf√≠o</p>
          <h2 id="retos-title">Retos finales (nivel avanzado)</h2>
          <p>
            Estos tres retos combinan m√∫ltiples conceptos. No tienen soluci√≥n trivial: necesitan dise√±o
            cuidadoso, elecci√≥n de estructuras y an√°lisis de complejidad. T√≥mate tu tiempo.
          </p>

          <!-- Reto A -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Reto A</p>
            <div><span class="tag tag-red">Grafos</span><span class="tag tag-red">DFS</span><span class="tag tag-red">Topolog√≠a</span></div>
            <h3>Ordenamiento topol√≥gico con detecci√≥n de ciclos</h3>
            <p><strong>Objetivo:</strong> Dado un grafo dirigido de n nodos y m aristas (representando dependencias entre tareas), determina un orden de ejecuci√≥n v√°lido (topol√≥gico). Si el grafo tiene un ciclo, indica que no es posible.</p>
            <p><strong>Restricciones:</strong> n ‚â§ 10‚Åµ, m ‚â§ 2√ó10‚Åµ. Soluci√≥n esperada: O(n + m).</p>
            <p><strong>Estructura sugerida:</strong> Lista de adyacencia (<code>vector&lt;vector&lt;int&gt;&gt;</code>), DFS con tres estados: no visitado, en proceso, terminado.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Usa DFS. Mant√©n tres estados: 0 = no visitado, 1 = en la pila actual, 2 = terminado. Si en el DFS llegas a un nodo con estado 1, hay un ciclo. Los nodos se agregan a la lista topol√≥gica en orden de finalizaci√≥n del DFS, luego se invierte el resultado.</div>
          </article>

          <!-- Reto B -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Reto B</p>
            <div><span class="tag tag-red">DP</span><span class="tag tag-red">Programaci√≥n din√°mica</span></div>
            <h3>Subsecuencia com√∫n m√°s larga (LCS)</h3>
            <p><strong>Objetivo:</strong> Dadas dos cadenas s1 y s2, encuentra la longitud de su subsecuencia com√∫n m√°s larga (LCS: Longest Common Subsequence). Una subsecuencia no necesita ser contigua.</p>
            <p><strong>Restricciones:</strong> |s1|, |s2| ‚â§ 1000. Soluci√≥n esperada: O(|s1| √ó |s2|) en tiempo y espacio.</p>
            <p><strong>Estructura sugerida:</strong> Tabla 2D de programaci√≥n din√°mica <code>dp[i][j]</code> = LCS de los primeros i caracteres de s1 y j de s2.</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">
              Define <code>dp[i][j]</code> como la LCS de <code>s1[0..i-1]</code> y <code>s2[0..j-1]</code>.<br>
              Si <code>s1[i-1] == s2[j-1]</code>: <code>dp[i][j] = dp[i-1][j-1] + 1</code>.<br>
              Si no: <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>.<br>
              Caso base: <code>dp[i][0] = dp[0][j] = 0</code>.
            </div>
          </article>

          <!-- Reto C -->
          <article class="ejercicio-card">
            <p class="ejercicio-num">Reto C</p>
            <div><span class="tag tag-red">Grafos</span><span class="tag tag-red">Dijkstra</span><span class="tag tag-red">Priority Queue</span></div>
            <h3>Camino m√°s corto con pesos (Dijkstra)</h3>
            <p><strong>Objetivo:</strong> Dado un grafo dirigido ponderado (con pesos ‚â• 0), encuentra las distancias m√≠nimas desde un nodo fuente S hacia todos los dem√°s nodos. Imprime "INF" si un nodo no es alcanzable.</p>
            <p><strong>Restricciones:</strong> n ‚â§ 10‚Åµ, m ‚â§ 2√ó10‚Åµ, pesos ‚â§ 10‚Åπ. Soluci√≥n esperada: O((n + m) log n).</p>
            <p><strong>Estructura sugerida:</strong> Lista de adyacencia, <code>priority_queue&lt;pair&lt;long long, int&gt;, vector&lt;pair&lt;long long,int&gt;&gt;, greater&lt;&gt;&gt;</code> (min-heap).</p>
            <button class="hint-toggle">üí° Ver pista</button>
            <div class="hint-content">Inicializa <code>dist[S] = 0</code> y <code>dist[i] = INF</code> para el resto. Usa un min-heap con pares (distancia, nodo). En cada iteraci√≥n, extrae el nodo con menor distancia actual y relaja sus vecinos: si <code>dist[u] + w(u,v) &lt; dist[v]</code>, actualiza y agrega al heap.</div>
          </article>

          <div class="callout callout-tip">
            <p class="callout-label">üí° Recursos para practicar m√°s</p>
            <p>Una vez resueltos estos ejercicios, practica en plataformas de jueces en l√≠nea como Codeforces,
            AtCoder, LeetCode o CSES Problem Set. Empieza por los problemas de nivel A y B antes de los C
            y superiores.</p>
          </div>
        </section>

        <hr class="divider">

        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             FORMULARIO DE CONTACTO
        ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <section id="contacto" aria-labelledby="contact-title">
          <p class="section-label">¬øPreguntas?</p>
          <h2 id="contact-title">Contacto</h2>
          <p>
            Si tienes dudas sobre el contenido, encontraste un error, o simplemente quieres dejar un
            comentario, usa este formulario.
          </p>

          <div class="callout callout-nota">
            <p class="callout-label">üìù Nota</p>
            <p>Formulario demostrativo: no env√≠a datos. Los campos tienen validaci√≥n en JavaScript y sirven
            para ilustrar buenas pr√°cticas de formularios web accesibles.</p>
          </div>

          <form id="contact-form" novalidate aria-label="Formulario de contacto">
            <div class="form-group">
              <label for="f-nombre">Nombre <span aria-hidden="true">*</span></label>
              <input
                type="text"
                id="f-nombre"
                name="nombre"
                autocomplete="name"
                placeholder="Tu nombre"
                aria-required="true"
                aria-describedby="e-nombre">
              <p class="field-error" id="e-nombre" role="alert" aria-live="polite"></p>
            </div>

            <div class="form-group">
              <label for="f-correo">Correo electr√≥nico <span aria-hidden="true">*</span></label>
              <input
                type="email"
                id="f-correo"
                name="correo"
                autocomplete="email"
                placeholder="tu@correo.com"
                aria-required="true"
                aria-describedby="e-correo">
              <p class="field-error" id="e-correo" role="alert" aria-live="polite"></p>
            </div>

            <div class="form-group">
              <label for="f-mensaje">Mensaje <span aria-hidden="true">*</span></label>
              <textarea
                id="f-mensaje"
                name="mensaje"
                placeholder="Escribe tu duda, sugerencia o comentario‚Ä¶"
                aria-required="true"
                aria-describedby="e-mensaje"></textarea>
              <p class="field-error" id="e-mensaje" role="alert" aria-live="polite"></p>
            </div>

            <button type="submit" class="btn btn-primary">Enviar mensaje ‚Üí</button>
            <p class="form-note">* Campos obligatorios. Formulario demostrativo: no env√≠a datos.</p>

            <!-- Toast de √©xito -->
            <div id="form-toast" role="status" aria-live="polite">
              ‚úÖ <strong>¬°Gracias!</strong> Este formulario es demostrativo y no env√≠a datos, pero tu mensaje est√° listo. ¬°Mucho √©xito con tus estudios!
            </div>
          </form>
        </section>

      </div><!-- /.content-wrapper -->
    </main>
  </div><!-- /.layout -->

  <!-- ‚îÄ‚îÄ Footer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <footer>
    <div class="footer-inner">
      <div class="footer-col">
        <h4>P√°ginas</h4>
        <ul>
          <li><a href="index.html">Inicio</a></li>
          <li><a href="historia.html">Gu√≠a completa</a></li>
          <li><a href="contacto.html">Ejercicios y contacto</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <h4>Ejercicios por nivel</h4>
        <ul>
          <li><a href="#ejercicios">B√°sicos (1‚Äì5)</a></li>
          <li><a href="#ejercicios-medio">Intermedios (6‚Äì10)</a></li>
          <li><a href="#retos">Retos avanzados (A‚ÄìC)</a></li>
          <li><a href="#contacto">Formulario de contacto</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <h4>Fuentes de referencia</h4>
        <ul>
          <li>Cormen et al. ‚Äî Introduction to Algorithms (CLRS)</li>
          <li>Knuth ‚Äî The Art of Computer Programming</li>
          <li>Sedgewick & Wayne ‚Äî Algorithms</li>
          <li>MIT OpenCourseWare ¬∑ Stanford CS</li>
          <li>cp-algorithms.com</li>
        </ul>
      </div>
    </div>
    <div class="footer-copy">
      <span>Proyecto acad√©mico de algoritmia ‚Äî HTML/CSS/JS puro</span>
      <span>Derechos Reservados</span>
    </div>
  </footer>

  <button id="back-to-top" aria-label="Volver al inicio">‚Üë</button>
  <script src="app.js"></script>
</body>
</html>